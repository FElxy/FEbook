# 闭包

链式作用域

概念

用途

实现

注意点

---

## 概念

在函数运行完毕后继续访问这个函数作用域(其变量)的一种方法。

闭包是指有权访问另外一个函数作用域中的变量的函数

## 特性

* 闭包可以访问当前函数以外的变量
* 即使外部函数已经返回，闭包仍能访问外部函数定义的变量
* 闭包可以更新外部变量的值

## 应用

### 模块

模块允许你定义外部不可见的私有实现细节(变量、函数)，同时也可以提供允许从外部访问的公开 API。

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();	// 3
data[1]();	// 3
data[2]();	// 3
```



**使用ES6中的let**

```js
var data = [];

for (let i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0]();
data[1]();
data[2]();
```

循环时，`let`声明`i`,所以整个块是块级作用域，那么data[0]这个函数就成了一个闭包。因为这个代码块中存在一个闭包，闭包的作用域链中引用着块级作用域，所以在闭包被调用之前，这个块级作用域内部的变量不会被销毁。

首先寻找该执行环境中是否存在`i`，没有找到，就沿着作用域链继续向上到了其所在的块作用域执行环境，找到了`i = 1`,于是输出了`1`。

**返回一个匿名函数赋值**

```js
var data = [];

for (var i = 0; i < 3; i++) {
  data[i] = (function (num) {
      return function(){
          console.log(num);
      }
  })(i);
}

data[0]();	// 0
data[1]();	// 1
data[2]();	// 2
```

**立即执行函数**

```js
for (var i = 0; i < 3; i++) {
    (function(num) {
        setTimeout(function() {
            console.log(num);
        }, 1000);
    })(i);
}
```



无论是**立即执行函数**还是**返回一个匿名函数赋值**，原理上都是因为变量的按值传递，所以会将变量`i`的值复制给实参`num`，在匿名函数的内部又创建了一个用于访问`num`的匿名函数，这样每个函数都有了一个`num`的副本，互不影响了。

todos
3-1思考题
现在主流浏览器的垃圾回收算法是**标记清除**，标记清除并非是标记执行栈的进出，而是**从根开始遍历**，也是一个找引用关系的过程，但是因为从根开始，相互引用的情况不会被计入。所以当垃圾回收开始时，从**Root**（全局对象）开始寻找这个对象的引用是否可达，如果引用链断裂，那么这个对象就会回收。
